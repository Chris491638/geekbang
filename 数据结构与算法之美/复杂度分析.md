# 为什么需要复杂度分析？

- 测试结果依赖测试环境
- 测试结果受数据规模影响较大

# 大O表示法

所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比

$T(n)=O(f(n))$

大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度，简称时间复杂度

# 时间复杂度分析

- 只关注循环执行次数最多的一段代码
- 加法法则：总复杂度等于量级最大的那段代码的复杂度
- 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

# 常见的时间复杂度
- $O(1)$
- $O(log^n)$
- $O(nlog^n)$
- $O(n^2),O(n^3)...$
- $O(2^n)$
- $O(n!)$

以上时间复杂度递增，前4种为多项式量级，后两种为非多项式量级，我们将时间复杂度为非多项式量级的算法问题称为NP问题。
当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。

# 最好、最坏时间复杂度

最好时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。例如，查找某数组中是否包含某变量，碰巧数组第一个元素就是此变量。

最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。例如，查找某数组中是否包含某变量，此变量不在数组中时，需遍历全部元素。

# 平均时间复杂度
最好和最坏时间复杂度都是极端情况下的时间复杂度，因此我们需要平均时间复杂度。
例如，要查找的变量 x 在数组中的位置，有 n+1 种情况：在数组的 0～n-1 位置中和不在数组中。我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以 n+1，就可以得到需要遍历的元素个数的平均值，即

$\frac{1+2+3+...+n+n}{n+1}=\frac{n(n+3)}{2(n+1)}$

简化可得时间复杂度为O(n)

上述问题中的 n+1 种情况出现的概率并不一样，假设在数组中和不在数组中概率都为$\frac{1}{2}$，要查找的n个位置出现的概率是一样的为$\frac{1}{n}$，因此，查找数据出现在0～n-1位置上的概率为$\frac{1}{2n}$，那么平均时间复杂度计算如下：

1*$\frac{1}{2n}$+2*$\frac{1}{2n}$+...+n*$\frac{1}{2n}$+n*$\frac{1}{2}$=$\frac{3n+1}{4}$

这个值就是概率论中的加权平均值，也叫作期望值，所以平均时间复杂度的全称应该叫加权平均时间复杂度或者期望时间复杂度